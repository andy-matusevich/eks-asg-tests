---

aliases:

  - &terraform_init
    name: terraform | infra init
    command: |
      cd $HOME/repo/terraform/infra
      terraform init \
        -backend-config="key=${CI_ENVIRONMENT}/${AWS_REGION}/terraform.tfstate" \
        -backend-config="bucket=${CIRCLE_PROJECT_REPONAME}" \
        -backend-config="region=${AWS_DEFAULT_REGION}"


jobs:

  terraform_prepare:
    executor: docker_terraform
    steps:
      - checkout
      - run:
          name: terraform | pre init
          command: |
            cd $HOME/repo/terraform/pre
            terraform init
      - run:
          name: terraform | check s3/dynamodb status
          command: |
            ### install awscli
            apk add --no-cache --virtual .build-deps g++ python3-dev libffi-dev openssl-dev curl sudo && \
            echo "Set disable_coredump false" >> /etc/sudo.conf && \
            apk add --no-cache --update python3 && \
            pip3 install --upgrade pip setuptools && \
            pip3 install awscli --upgrade

            ### check s3 state bucket
            aws s3api get-bucket-location --bucket ${CIRCLE_PROJECT_REPONAME} > /dev/null 2>&1 && \
            echo $? > $HOME/repo/terraform/pre/.terraform/s3.status || \
            echo $? > $HOME/repo/terraform/pre/.terraform/s3.status && true

            ### check lock table status
            aws dynamodb describe-table --table-name ${CIRCLE_PROJECT_REPONAME}-locks > /dev/null 2>&1 && \
            echo $? > $HOME/repo/terraform/pre/.terraform/lock-table.status || \
            echo $? > $HOME/repo/terraform/pre/.terraform/lock-table.status && true
      - run:
          name: terraform | apply tf state s3 bucket
          command: |
            cd $HOME/repo/terraform/pre
            if [ $(cat .terraform/s3.status) != 0 ]; then
              terraform apply \
                -auto-approve \
                -lock=true \
                -input=false \
                -lock-timeout=30s \
                -refresh=true \
                -target=aws_s3_bucket.tfstate-storage-s3 \
                -var="state_region=${AWS_DEFAULT_REGION}" \
                -var="state_bucket=${CIRCLE_PROJECT_REPONAME}" \
                -var="state_lock_table=${CIRCLE_PROJECT_REPONAME}-tfstate-locks"
            else
              echo -e "S3 bucket is already exists"
            fi
      - run:
          name: terraform | apply lock dynamodb table
          command: |
            cd $HOME/repo/terraform/pre
            if [ $(cat .terraform/lock-table.status) != 0 ]; then
              terraform apply \
                -auto-approve \
                -lock=true \
                -input=false \
                -lock-timeout=30s \
                -refresh=true \
                -target=aws_dynamodb_table.tfstate-locks \
                -var="state_region=${AWS_DEFAULT_REGION}" \
                -var="state_bucket=${CIRCLE_PROJECT_REPONAME}" \
                -var="state_lock_table=${CIRCLE_PROJECT_REPONAME}-tfstate-locks"
            else
              echo -e "DynamoDB table is already exists"
            fi

  terraform_validate:
    executor: docker_terraform
    steps:
      - checkout
      - run: *terraform_init
      - run:
          name: terraform | infra validate
          command: |
            cd $HOME/repo/terraform/infra
            terraform validate

  terraform_plan:
    executor: docker_terraform
    steps:
      - checkout
      - run: *terraform_init
      - run:
          name: terraform | infra plan
          command: |
            cd $HOME/repo/terraform/infra
            terraform plan \
              -out=".terraform/terraform.tfplan" \
              -var="cluster_name=${CIRCLE_PROJECT_REPONAME}" \
              -var="environment=${CI_ENVIRONMENT}" \
              -var="region=${AWS_REGION}" \
              -var-file=${CI_ENVIRONMENT}.tfvars
      - persist_to_workspace:
          root: './'
          paths:
            - 'terraform/*'

  terraform_apply:
    executor: docker_terraform
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - run: *terraform_init
      - run:
          name: terraform | infra apply
          command: |
            cd $HOME/repo/terraform/infra
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=120s \
              -refresh=true \
              .terraform/terraform.tfplan
      - run:
          name: terraform | output config_map_aws_auth
          command: |
            cd $HOME/repo/terraform/infra
            terraform output
            terraform output cluster_name > $HOME/repo/terraform/infra/.terraform/output.cluster_name
            terraform output kubeconfig > $HOME/repo/terraform/infra/.terraform/output.kubeconfig
      - persist_to_workspace:
          root: './'
          paths:
            - 'terraform/*'

  install_apps:
    executor: base
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - kubernetes/install
      - run:
          name: manage kubectl config
          command: |
            mkdir -p ~/.kube/
            cat $HOME/repo/terraform/infra/.terraform/output.kubeconfig > ~/.kube/config
      - aws-eks/install-eksctl
      - run:
          name: get cluster name from terraform output
          command: |
            echo "export TFVAR_EKS_CLUSTER_NAME=$( cat $HOME/repo/terraform/infra/.terraform/output.cluster_name )" >> $BASH_ENV
      - aws-eks/update-kubeconfig-with-authenticator:
          aws-region: "${AWS_REGION}"
          cluster-name: "${TFVAR_EKS_CLUSTER_NAME}"
      - run:
          name: install helm
          command: |
            wget -O - http://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
      - run:
          name: install nginx
          command: |
            helm repo add bitnami https://charts.bitnami.com/bitnami
            helm repo update
            kubectl create namespace nginx
            helm install nginx bitnami/nginx --namespace nginx
            export SERVICE_IP=$(kubectl get svc --namespace nginx nginx --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}")
            echo "NGINX URL: http://$SERVICE_IP/"

      - persist_to_workspace:
          root: './'
          paths:
            - 'terraform/*'

orbs:
  aws-eks: circleci/aws-eks@0.2.7
  kubernetes: circleci/kubernetes@0.11.0

version: 2.1

executors:

  docker_terraform:
    docker:
      - image: 'hashicorp/terraform:0.12.25'
    resource_class: 'small'
    shell: /bin/sh -leo pipefail
    environment:
      - BASH_ENV: /etc/profile
    working_directory: '~/repo'

  base:
    docker:
      - image: 'circleci/python:3.8.1'
    resource_class: 'small'
    working_directory: '~/repo'


workflows:

  eks-prod:
    jobs:
      - terraform_prepare:
          context: env-prod
          filters:
            branches:
              only: master
      - terraform_validate:
          context: env-prod
          requires:
            - terraform_prepare
          filters:
            branches:
              only: master
      - terraform_plan:
          context: env-prod
          requires:
            - terraform_validate
          filters:
            branches:
              only: master
      - approve_prod:
          type: approval
          requires:
            - terraform_validate
            - terraform_plan
          filters:
            branches:
              only: master
      - terraform_apply:
          context: env-prod
          requires:
            - terraform_plan
            - approve_prod
          filters:
            branches:
              only: master
      - install_apps:
          context: env-prod
          requires:
            - terraform_apply
          filters:
            branches:
              only: master

  eks-staging:
    jobs:
      - terraform_prepare:
          context: env-staging
          filters:
            branches:
              ignore: master
      - terraform_validate:
          context: env-staging
          requires:
            - terraform_prepare
          filters:
            branches:
              ignore: master
      - terraform_plan:
          context: env-staging
          requires:
            - terraform_validate
          filters:
            branches:
              ignore: master
      - approve_staging:
          type: approval
          requires:
            - terraform_validate
            - terraform_plan
          filters:
            branches:
              ignore: master
      - terraform_apply:
          context: env-staging
          requires:
            - terraform_plan
            - approve_staging
          filters:
            branches:
              ignore: master
      - install_apps:
          context: env-staging
          requires:
            - terraform_apply
          filters:
            branches:
              ignore: master

