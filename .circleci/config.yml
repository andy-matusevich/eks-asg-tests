---

aliases:

  - &terraform_init
    name: terraform | infra init
    command: |
      cd ${TF_INFRA_DIR} && \
      terraform init \
        -backend-config="key=${CI_ENVIRONMENT}/terraform.tfstate" \
        -backend-config="bucket=${TF_STATE_BUCKETNAME}" \
        -backend-config="region=${AWS_DEFAULT_REGION}"

jobs:

  terraform_prepare:
    executor: docker_terraform
    steps:
      - checkout
      - run:
          name: terraform | pre init
          command: |
            cd ${TF_PRE_DIR}
            terraform init
      - run:
          name: terraform | pre plan
          command: |
            cd ${TF_PRE_DIR}
            terraform plan \
              -out=".terraform/terraform.tfplan" \
              -var="tfstate_region=${AWS_DEFAULT_REGION}" \
              -var="tfstate_bucket=${TF_STATE_BUCKETNAME}" \
              -var="tfstate_lock_table=${TF_STATE_LOCK_TABLE}"
      - run:
          name: terraform | check s3/dynamodb status
          command: |
            apk add --no-cache --virtual .build-deps g++ python3-dev libffi-dev openssl-dev curl sudo && \
            echo "Set disable_coredump false" >> /etc/sudo.conf && \
            apk add --no-cache --update python3 && \
            pip3 install --upgrade pip setuptools && \
            pip3 install awscli --upgrade && \
            aws s3api get-bucket-location --bucket ${TF_STATE_BUCKETNAME} > /dev/null 2>&1 && \
            aws dynamodb describe-table --table-name ${TF_STATE_LOCK_TABLE} > /dev/null 2>&1
            export CHECK_STATUS=$?
      - run:
          name: terraform | pre apply
          command: |
            cd ${TF_PRE_DIR}
            if [ ${CHECK_STATUS} != 0]; then
              terraform apply \
                -auto-approve \
                -lock=true \
                -input=false \
                -lock-timeout=30s \
                -refresh=true \
                .terraform/terraform.tfplan;
            else
              echo -e "[${TF_STATE_BUCKETNAME}] bucket is already exists"
              echo -e "[${TF_STATE_LOCK_TABLE}] table is already exists"
              echo -e "Skipping applying tf plan"
            fi

  terraform_validate:
    executor: docker_terraform
    steps:
      - checkout
      - run: *terraform_init
      - run:
          name: terraform | infra validate
          command: |
            cd ${TF_INFRA_DIR}
            terraform validate

  terraform_plan:
    executor: docker_terraform
    steps:
      - checkout
      - run: *terraform_init
      - run:
          name: terraform | infra plan
          command: |
            cd ${TF_INFRA_DIR}
            terraform plan \
              -out=".terraform/terraform.tfplan"
      - persist_to_workspace:
          root: './'
          paths:
            - 'terraform/*'

  terraform_apply:
    executor: docker_terraform
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - run: *terraform_init
      - run:
          name: terraform | infra apply
          command: |
            cd ${TF_INFRA_DIR}
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=120s \
              -refresh=true \
              .terraform/terraform.tfplan
      - run:
          name: terraform | output config_map_aws_auth
          command: |
            cd ${TF_INFRA_DIR}
            terraform output
            terraform output cluster_name > ${TF_INFRA_DIR}/.terraform/output.cluster_name
            terraform output kubeconfig > ${TF_INFRA_DIR}/.terraform/output.kubeconfig
      - persist_to_workspace:
          root: './'
          paths:
            - 'terraform/*'

  terraform_destroy:
    executor: docker_terraform
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - run: *terraform_init
      - run:
          name: terraform | infra destroy
          command: |
            cd ${TF_INFRA_DIR}
            terraform destroy \
              -auto-approve \
              -lock=true \
              -lock-timeout=120s \
              -refresh=true

  configure_eks:
    executor: base
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - kubernetes/install
      - run:
          name: manage kubectl config
          command: |
            mkdir ~/.kube/
            cat ${TF_INFRA_DIR}/.terraform/output.kubeconfig > ~/.kube/config
      - aws-eks/install-eksctl
      - run:
          name: get cluster name from terraform output
          command: |
            echo "export TFVAR_EKS_CLUSTER_NAME=$( cat ${TF_INFRA_DIR}/.terraform/output.cluster_name )" >> $BASH_ENV
      - aws-eks/update-kubeconfig-with-authenticator:
          cluster-name: "${TFVAR_EKS_CLUSTER_NAME}"
      - run:
          name: install helm
          command: |
            wget -O - http://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash


orbs:
  aws-eks: circleci/aws-eks@0.2.7
  kubernetes: circleci/kubernetes@0.11.0

version: 2.1

executors:

  docker_terraform:
    docker:
      - image: 'hashicorp/terraform:0.12.24'
    resource_class: 'small'
    working_directory: '/var/repo'
    shell: /bin/sh -leo pipefail
    environment:
      - BASH_ENV: /etc/profile

  base:
    docker:
      - image: 'circleci/python:3.8.1'
    resource_class: 'small'
    working_directory: '/var/repo'


workflows:

  deploy_prod:
    jobs:
      - terraform_prepare:
          context: env-prod
      - terraform_validate:
          context: env-prod
          requires:
            - terraform_prepare
      - terraform_plan:
          context: env-prod
          requires:
            - terraform_validate
      - approve_prod:
          type: approval
          requires:
            - terraform_validate
            - terraform_plan
      - terraform_apply:
          context: env-prod
          requires:
            - terraform_plan
            - approve_prod
      - configure_eks:
          context: env-prod
          requires:
            - terraform_apply
      - approve_terraform_destroy:
          type: approval
          requires:
            - terraform_apply
      - terraform_destroy:
          context: env-prod
          requires:
            - approve_terraform_destroy