---

aliases:

  - &terraform_init
    name: terraform | infra init
    command: |
      cd terraform/infra
      terraform init \
        -backend-config="key=${CI_ENVIRONMENT}/${AWS_REGION}/terraform.tfstate" \
        -backend-config="bucket=${CIRCLE_PROJECT_REPONAME}" \
        -backend-config="region=${AWS_DEFAULT_REGION}"


jobs:

  terraform_prepare:
    executor: docker_terraform
    working_directory: '~/repo'
    steps:
      - checkout
      - run:
          name: terraform | pre init
          command: |
            cd terraform/pre
            terraform init
      - run:
          name: terraform | check s3/dynamodb status
          command: |
            cd terraform/pre
            ### install awscli
            pwd && apk add --no-cache --virtual .build-deps g++ python3-dev libffi-dev openssl-dev curl sudo && \
            echo "Set disable_coredump false" >> /etc/sudo.conf && \
            apk add --no-cache --update python3 && \
            pip3 install --upgrade pip setuptools && \
            pip3 install awscli --upgrade

            ### check s3 state bucket
            aws s3api get-bucket-location --bucket ${CIRCLE_PROJECT_REPONAME} > /dev/null 2>&1 && \
            echo $? > .terraform/s3.status || \
            echo $? > .terraform/s3.status && true

            ### check lock table status
            aws dynamodb describe-table --table-name ${CIRCLE_PROJECT_REPONAME}-locks > /dev/null 2>&1 && \
            echo $? > .terraform/lock-table.status || \
            echo $? > .terraform/lock-table.status && true
      - run:
          name: terraform | apply tf state s3 bucket
          command: |
            cd terraform/pre
            if [ $(cat .terraform/s3.status) != 0 ]; then
              terraform apply \
                -auto-approve \
                -lock=true \
                -input=false \
                -lock-timeout=30s \
                -refresh=true \
                -target=aws_s3_bucket.tfstate-storage-s3 \
                -var="state_region=${AWS_DEFAULT_REGION}" \
                -var="state_bucket=${CIRCLE_PROJECT_REPONAME}" \
                -var="state_lock_table=${CIRCLE_PROJECT_REPONAME}-tfstate-locks"
            else
              echo -e "S3 bucket is already exists"
            fi
      - run:
          name: terraform | apply lock dynamodb table
          command: |
            cd terraform/pre
            if [ $(cat .terraform/lock-table.status) != 0 ]; then
              terraform apply \
                -auto-approve \
                -lock=true \
                -input=false \
                -lock-timeout=30s \
                -refresh=true \
                -target=aws_dynamodb_table.tfstate-locks \
                -var="state_region=${AWS_DEFAULT_REGION}" \
                -var="state_bucket=${CIRCLE_PROJECT_REPONAME}" \
                -var="state_lock_table=${CIRCLE_PROJECT_REPONAME}-tfstate-locks"
            else
              echo -e "DynamoDB table is already exists"
            fi

  terraform_validate:
    executor: docker_terraform
    working_directory: '~/repo'
    steps:
      - checkout
      - run: *terraform_init
      - run:
          name: terraform | infra validate
          command: |
            cd terraform/infra
            terraform validate

  terraform_apply:
    executor: docker_terraform
    working_directory: '~/repo'
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - run:
          command: |
            cd terraform/infra
            apk update && apk add curl
      - run: *terraform_init
      - run:
          name: terraform | infra plan
          command: |
            cd terraform/infra
            terraform plan \
              -out=".terraform/terraform.tfplan" \
              -var="cluster_name=${CIRCLE_PROJECT_REPONAME}" \
              -var="environment=${CI_ENVIRONMENT}" \
              -var="region=${AWS_REGION}" \
              -var-file=${CI_ENVIRONMENT}.tfvars
      - run:
          name: terraform | infra apply
          command: |
            cd terraform/infra
            terraform apply \
              -auto-approve \
              -lock=true \
              -input=false \
              -lock-timeout=30s \
              -refresh=true \
              .terraform/terraform.tfplan
      - kubernetes/install
      - run:
          name: eks | manage kubectl config
          command: |
            cd terraform/infra
            mkdir -p ~/.kube/
            terraform output kubeconfig > ~/.kube/config
      - aws-eks/install-eksctl
      - run:
          name: eks | get cluster name from terraform output
          command: |
            echo "export AWS_EKS_CLUSTER_NAME=$( terraform output cluster_name )" >> $BASH_ENV
      - aws-eks/update-kubeconfig-with-authenticator:
          aws-region: "${AWS_REGION}"
          cluster-name: "${AWS_EKS_CLUSTER_NAME}"
      - persist_to_workspace:
          root: './'
          paths:
            - 'terraform/*'

  install_ingress:
    executor: base
    working_directory: '~/repo'
    steps:
      - checkout
      - attach_workspace:
          at: '.'
      - run:
          name: install helm
          command: |
            wget -O - http://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
      - run:
          name: install nginx-ingress (nlb)
          command: |
            helm repo add nginx-stable https://helm.nginx.com/stable
            helm repo update
            helm install nginx nginx-stable/nginx-ingress \
            	--namespace ingress \
            	--create-namespace \
            	--set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"=nlb


orbs:
  aws-eks: circleci/aws-eks@0.2.7
  kubernetes: circleci/kubernetes@0.11.0

version: 2.1

executors:

  docker_terraform:
    docker:
      - image: 'hashicorp/terraform:0.12.25'
    resource_class: 'small'
    shell: /bin/sh -leo pipefail
    environment:
      - BASH_ENV: /etc/profile

  base:
    docker:
      - image: 'circleci/python:3.8.1'
    resource_class: 'small'
    working_directory: '~/repo'


workflows:

  eks-prod:
    jobs:
      - terraform_prepare:
          context: env-prod
          filters:
            branches:
              only: master
      - terraform_validate:
          context: env-prod
          requires:
            - terraform_prepare
          filters:
            branches:
              only: master
      - approve_prod:
          type: approval
          requires:
            - terraform_validate
          filters:
            branches:
              only: master
      - terraform_apply:
          context: env-prod
          requires:
            - approve_prod
          filters:
            branches:
              only: master
      - install_ingress:
          context: env-prod
          requires:
            - terraform_apply
          filters:
            branches:
              only: master

  eks-staging:
    jobs:
      - terraform_prepare:
          context: env-staging
          filters:
            branches:
              ignore: master
      - terraform_validate:
          context: env-staging
          requires:
            - terraform_prepare
          filters:
            branches:
              ignore: master
      - approve_staging:
          type: approval
          requires:
            - terraform_validate
          filters:
            branches:
              ignore: master
      - terraform_apply:
          context: env-staging
          requires:
            - approve_staging
          filters:
            branches:
              ignore: master
      - install_ingress:
          context: env-staging
          requires:
            - terraform_apply
          filters:
            branches:
              ignore: master

